<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>My first three.js app</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <script id="shader-vs" type="x-shader/x-vertex">
      //uniform sampler2D u_texture;

      out vec2 v_uv;

      // A magenta color for referencing
      // Refer to line 311 to 315, we set a point to magenta color.
      // And we will compare the magenta point with this vec4 magenta.
      vec4 magenta = vec4(1.0, 0.0, 1.0, 1.0);
      vec4 topLeft;

      void main(void) {
        // Correction work
        //topLeft = texture(u_texture, vec2(0.0, 0.0));
        //// We want to check if the magenta point is rendered in top left corner
        //// If not, flip it
        //if (topLeft == magenta)
        //  v_uv = vec2(aVertexUVs.x, aVertexUVs.y);
        //else
        //  v_uv = vec2(aVertexUVs.x, 1.0 - aVertexUVs.y);
		v_uv = position.xy * vec2(0.5, 0.5) + vec2(0.5, 0.5);
        gl_Position = vec4(position.xyz, 1.0);
      }
    </script>
    <script id="shader-fs" type="x-shader/x-fragment">
      precision mediump float;
      precision highp int;
      
      //Input Format
      in highp vec2 v_uv;

      uniform sampler2D u_texture;
      uniform sampler2D u_depth;
      
      //layout(location = 0) out highp vec4 out_var_SV_Target0;

      void main()
      {
        vec4 col = texture2D(u_texture, v_uv);
        float depth = texture2D(u_depth, v_uv).x;

        gl_FragColor = vec4(col.zyx, 1.0);
        gl_FragDepth = depth * 0.5 + 0.5;
      }
    </script>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "./js/three.module.js",
          "three/addons/": "./js/jsm/"
        }
      }

    </script>

    <script type="module">
      import * as THREE from "three";

      import Stats from "three/addons/libs/stats.module.js";
      import WebGL from "three/addons/capabilities/WebGL.js";
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      if (WebGL.isWebGL2Available() === false) {
        document.body.appendChild(WebGL.getWebGL2ErrorMessage());
      }

      let scene, mesh, renderer, stats;
      let colourTextureGL, udTextureDepth;

      camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
      camera.up.set(0,0,1);
      camera.position.x = -0.1;	
      camera.position.y = -0.1;
      camera.position.z = -0.02;

      scene = new THREE.Scene(); 

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls( camera, renderer.domElement );
      controls.update();

      stats = new Stats();
      document.body.appendChild(stats.dom);
      window.addEventListener("resize", onWindowResize);

      let material = new THREE.ShaderMaterial({
        uniforms: {
          u_texture: { type: "t", value: null },
          u_depth: { type: "t", value: null },
        },
        vertexShader: document.getElementById("shader-vs").textContent.trim(),
        fragmentShader: document.getElementById("shader-fs").textContent.trim(),
        depthWrite: true
      });

      let geometry = new THREE.BufferGeometry();
      const vertices = new Float32Array([-1,-1,0,  1,-1,0,  1,1,0, -1,-1,0,  1,1,0,  -1,1,0]);
      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(vertices, 3)
      );
      mesh = new THREE.Mesh(geometry, material);
      mesh.position.set( 0, 0, 0 );
      scene.add(mesh);

      ///// test
      const boxGeometry = new THREE.BoxGeometry( 0.05,  0.05,  0.05 );
      const texture = new THREE.TextureLoader().load( 'crate.gif' );
      let boxObject = new THREE.Mesh( boxGeometry, new THREE.MeshBasicMaterial( { map: texture } ) );
      boxObject.position.set( 0, 0, 0 );
      scene.add( boxObject );
      /////

      camera.lookAt(scene.position);
      animate();

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
		
        let width = window.innerWidth;
        let height = window.innerHeight;


        if (udSDKJSReady) {
		  
		  udSDKJS_ResizeScene(width, height, 0, 0);

          var pm = camera.projectionMatrix.elements;
          udSDKJS_SetMatrix(
            "projection",
            pm[0],
            pm[1],
            pm[2],
            pm[3],
            pm[4],
            pm[5],
            pm[6],
            pm[7],
            pm[8],
            pm[9],
            pm[10],
            pm[11],
            pm[12],
            pm[13],
            pm[14],
            pm[15]
          );

          var m = camera.matrix.elements;
          udSDKJS_SetMatrix(
            "camera",
            m[0],
            m[1],
            m[2],
            m[3],
            m[4],
            m[5],
            m[6],
            m[7],
            m[8],
            m[9],
            m[10],
            m[11],
            m[12],
            m[13],
            m[14],
            m[15]
            );

          udSDKJS_RenderQueue();
          var ptr = udSDKJS_GetColourBuffer();
          var data = new Uint8Array(
            HEAPU8.subarray(ptr, ptr + width * height * 4)
          );

          colourTextureGL = new THREE.DataTexture(
            data,
            width,
            height
          );
          colourTextureGL.type = THREE.UnsignedByteType;
          colourTextureGL.format = THREE.RGBAFormat;
          colourTextureGL.needsUpdate = true;

          var ptr = udSDKJS_GetDepthBuffer();
          var dataHeapF32 = new Float32Array(
            HEAPF32.subarray(ptr >> 2, (ptr + width * height * 4) >> 2)
          );

          udTextureDepth = new THREE.DepthTexture(
            dataHeapF32,
            width,
            height,
          );
          udTextureDepth.type = THREE.FloatType;
          udTextureDepth.format = THREE.DepthFormat;
          udTextureDepth.needsUpdate = true;

          material.uniforms.u_texture.value = colourTextureGL;
          material.uniforms.u_depth.value = udTextureDepth;

          ///test
          boxObject.rotation.z += 0.2;
  
          stats.update();
          renderer.render(scene, camera);
        }
      }

      function onWindowResize() {
        udSDKJS_ResizeScene(window.innerWidth, window.innerHeight, 0, 0);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
      }
    </script>

    <script>
      const udSDKjs = document.createElement("script");
      udSDKjs.src = "./euclideon/udSDKjs.js";
      document.body.appendChild(udSDKjs);

      const easyudSDKjs = document.createElement("script");
      easyudSDKjs.src = "./euclideon/easyudSDKjs.js";
      document.body.appendChild(easyudSDKjs);

      var udSDKJSReady = false;
      var camera;

    </script>
    <div id="viewDiv">
      <div id="view3D" class="viewPortal"></div>
    </div>
    <div id="loginBox">
      <span id="errorMessage" style="color: red"></span>
    </div>
    <script>
      function udSDKInit() {
        udSDKJS_RegisterShared();

        var status = udSDKJS_CreateSharedFrom_udCloud("Esri ArcScene").then(
          function() {
            // LiDAR of Vancouver available as [Open Data](https://opendata.vancouver.ca/pages/home/).
            //udSDKJS_LoadModel("https://models.euclideon.com/Vancouver_Colour.uds").then(
              let apple_uds = "https://fa-data-aueast-01.udcloud.euclideon.com/api/YZukILKU40uvb4qWI2SVg/_sharecode/TvCH2FoUKUSoZS5QgLr0Lg/_file/zUiBwcuHUG1st8UXlmg/apple.uds";
            udSDKJS_LoadModel(apple_uds).then(
              function(modelHandle) {
                let m = [1,0,0,0, 0,1,0,0, 0,0,-1,0, 0,0,0,1];
                let ret = udSDKJS_RenderQueueAddModelWithMatrix(modelHandle, m);
                if(ret < 0)
                  console.log(udSDKJS_GetErrorString(ret));
                else
                  console.log("load succ slotID:" + ret);
              }, function(code) {
                console.log(udSDKJS_GetErrorString(code));
              }
            );

            udSDKJSReady = true;
            document.getElementById("loginBox").style.display = "none"; // Hide this if it was presented previously
          },
          function(code) {
            document.getElementById("loginBox").style.display = "block";
            if (code == 13)
              document.getElementById("errorMessage").innerText = "udSDKJS Error / Email or Password Wrong";
            else
              document.getElementById("errorMessage").innerText = "udSDKJS FAILED Error=" + code;
          }
        );
      }

      var Module = {
        noExitRuntime: true,
        preRun: [],
        postRun: udSDKInit,
        setStatus: function (text) {
          if (!Module.setStatus.last)
            Module.setStatus.last = { time: Date.now(), text: "" };

          if (text === Module.setStatus.last.text) return;

          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon

          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
          }

          console.log(text);
        },
        totalDependencies: 0,
        monitorRunDependencies: function (left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(
            left
              ? "Preparing... (" +
                  (this.totalDependencies - left) +
                  "/" +
                  this.totalDependencies +
                  ")"
              : "All downloads complete."
          );
        },
      };

      Module.setStatus("Downloading...");
    </script>
  </body>
</html>
