<!DOCTYPE html>
<html lang="en">
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,width=device-width" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.5.0/math.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://www.euclideon.com/demo/esri_city_viewer/arcgis_js/4.20/esri/themes/dark/main.css" />
  <script src="https://www.euclideon.com/demo/esri_city_viewer/arcgis_js/4.20/init.js"></script>

  <link rel="stylesheet" href="./css/main.css" />
  <script src="./lib/cameraControl.js"></script>
  <script src="./lib/loadModel.js"></script>
  <title>ESRI City Viewer</title>
  <head>
    <!-- A simple fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
      #extension GL_EXT_frag_depth : enable
      precision highp float;

      //RGBA to Float from https://github.com/ihmeuw/glsl-rgba-to-float/blob/master/index.glsl
      // Denormalize 8-bit color channels to integers in the range 0 to 255.
      ivec4 floatsToBytes(vec4 inputFloats, bool littleEndian) {
        ivec4 bytes = ivec4(inputFloats * 255.0);
        return (
          littleEndian
          ? bytes.abgr
          : bytes
        );
      }

      // Break the four bytes down into an array of 32 bits.
      void bytesToBits(const in ivec4 bytes, out bool bits[32]) {
        for (int channelIndex = 0; channelIndex < 4; ++channelIndex) {
          float acc = float(bytes[channelIndex]);
          for (int indexInByte = 7; indexInByte >= 0; --indexInByte) {
            float powerOfTwo = exp2(float(indexInByte));
            bool bit = acc >= powerOfTwo;
            bits[channelIndex * 8 + (7 - indexInByte)] = bit;
            acc = mod(acc, powerOfTwo);
          }
        }
      }

      // Compute the exponent of the 32-bit float.
      float getExponent(bool bits[32]) {
        const int startIndex = 1;
        const int bitStringLength = 8;
        const int endBeforeIndex = startIndex + bitStringLength;
        float acc = 0.0;
        int pow2 = bitStringLength - 1;
        for (int bitIndex = startIndex; bitIndex < endBeforeIndex; ++bitIndex) {
          acc += float(bits[bitIndex]) * exp2(float(pow2--));
        }
        return acc;
      }

      // Compute the mantissa of the 32-bit float.
      float getMantissa(bool bits[32], bool subnormal) {
        const int startIndex = 9;
        const int bitStringLength = 23;
        const int endBeforeIndex = startIndex + bitStringLength;
        // Leading/implicit/hidden bit convention:
        // If the number is not subnormal (with exponent 0), we add a leading 1 digit.
        float acc = float(!subnormal) * exp2(float(bitStringLength));
        int pow2 = bitStringLength - 1;
        for (int bitIndex = startIndex; bitIndex < endBeforeIndex; ++bitIndex) {
          acc += float(bits[bitIndex]) * exp2(float(pow2--));
        }
        return acc;
      }

      // Parse the float from its 32 bits.
      float bitsToFloat(bool bits[32]) {
        float signBit = float(bits[0]) * -2.0 + 1.0;
        float exponent = getExponent(bits);
        bool subnormal = abs(exponent - 0.0) < 0.01;
        float mantissa = getMantissa(bits, subnormal);
        float exponentBias = 127.0;
        return signBit * mantissa * exp2(exponent - exponentBias - 23.0);
      }

      // Decode a 32-bit float from the RGBA color channels of a texel.
      float rgbaToFloat(vec4 texelRGBA, bool littleEndian) {
        ivec4 rgbaBytes = floatsToBytes(texelRGBA, littleEndian);
        bool bits[32];
        bytesToBits(rgbaBytes, bits);
        return bitsToFloat(bits);
      }

      //Input Format
      varying vec2 v_uv;

      uniform sampler2D u_texture;
      uniform sampler2D u_depth;

      void main()
      {
        vec4 col = texture2D(u_texture, v_uv);
        float depth = rgbaToFloat(texture2D(u_depth, v_uv), true);

        // Setting pixel colors. R G B A
        gl_FragColor = vec4(col.zyx, 1.0);
        gl_FragDepthEXT = depth * 0.5 + 0.5;
      }
    </script>

    <!-- A simple vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec2 aVertexPosition;
      attribute vec2 aVertexUVs;
      uniform sampler2D u_texture;
      varying vec2 v_uv;

      // A magenta color for referencing
      // Refer to line 311 to 315, we set a point to magenta color.
      // And we will compare the magenta point with this vec4 magenta.
      vec4 magenta = vec4(1.0, 0.0, 1.0, 1.0);
      vec4 topLeft;

      void main(void) {
        // Correction work
        topLeft = texture2D(u_texture, vec2(0.0, 0.0));
        // We want to check if the magenta point is rendered in top left corner
        // If not, flip it
        if (topLeft == magenta)
          v_uv = vec2(aVertexUVs.x, aVertexUVs.y);
        else
          v_uv = vec2(aVertexUVs.x, 1.0 - aVertexUVs.y);
        gl_Position = vec4(aVertexPosition.xy, 0.0, 1.0);
      }
    </script>

    <!-- Our application -->
    <script>
      var udSDKJSReady = 0;
      var viewer = null;
      var resolution = 1.0;
      var buildingsLayer;
      var lightsLayer;
      var treesLayer;
      var cursorX = -1;
      var cursorY = -1;
      var dataHeap;
      var vpMatrix;
      var clickedPoints = [];
      var clickedPointsArea = [];
      var drewLine = [];
      var drewArea = [];
      
      require([
        "esri/Map",
        "esri/Viewpoint",
        "esri/views/SceneView",
        "esri/views/3d/externalRenderers",
        "esri/widgets/Home",
        "esri/widgets/Search",
        "esri/widgets/Legend",
        "esri/widgets/Expand",
        "esri/layers/FeatureLayer",
        "esri/symbols/ExtrudeSymbol3DLayer",
        "esri/core/promiseUtils",
        "esri/layers/DirectLineMeasurementLayer",
        "esri/layers/AreaMeasurementLayer",
        "esri/Graphic",
        "esri/geometry/Point",
        "esri/geometry/Polygon",
        "esri/geometry/SpatialReference"
      ], function(
        Map,
        Viewpoint,
        SceneView,
        externalRenderers,
        Home,
        Search,
        Legend,
        Expand,
        FeatureLayer,
        ExtrudeSymbol3DLayer,
        promiseUtils,
        DirectLineMeasurementLayer,
        AreaMeasurementLayer,
        Graphic,
        Point,
        Polygon,
        SpatialReference
      ) {

        // Initialise measure tool variable
        let activeWidget = -1;

        // Set up the external renderer
        const udSDKRenderer = {
          // Input data
          view: null,
          prevWidth: 0,
          prevHeight: 0,

          // Vertex and index buffers
          vbo: null,
          texture: null,
          textureDepth: null,

          // Shader
          program: null,

          // Shader attribute and uniform locations
          programAttribVertexPosition: null,
          programAttribVertexTexture: null,

          textureLocation: null,
          textureLocationDepth: null,

          /**
           * Constructor
           */
          constructor: function(view) {
            this.view = view;
          },

          /**
           * Called once after this external renderer is added to the scene.
           * This is part of the external renderer interface.
           */
          setup: function(context) {
            this.initShaders(context);

            this.prevWidth = context.camera.width * resolution;
            this.prevHeight = context.camera.height * resolution;

            var gl = context.gl;

            this.vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);

            var vertData = new Float32Array([-1,-1,0,1,  1,-1,1,1,  1,1,1,0, -1,-1,0,1,  1,1,1,0,  -1,1,0,0]);
            gl.bufferData(gl.ARRAY_BUFFER, vertData, gl.STATIC_DRAW);

            var position = gl.getAttribLocation(this.program, "aVertexPosition");
            gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 16, 0);
            gl.enableVertexAttribArray(position);

            var texCoord = gl.getAttribLocation(this.program, "aVertexUVs");
            gl.vertexAttribPointer(texCoord, 2, gl.FLOAT, false, 16, 8);
            gl.enableVertexAttribArray(texCoord);

            data = new Uint8Array([255, 255, 255, 255]);

            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);

            this.textureDepth = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.textureDepth);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
          },

          /**
           * Called each time the scene is rendered.
           * This is part of the external renderer interface.
           */
          render: function(context) {
            var gl = context.gl;

            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);

            gl.useProgram(this.program);
            gl.uniform1i(this.textureLocation, 0);
            gl.uniform1i(this.textureLocationDepth, 1);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.texture);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, this.textureDepth);

            var width = context.camera.width * resolution; // 1024
            var height = context.camera.height * resolution; // 1024
            if (udSDKJSReady == 2)
            {
              // If the window's size has changed.
              if (width != this.prevWidth || height != this.prevHeight)
              {
                this.prevWidth = width;
                this.prevHeight = height;
                // We need width x height x 4 byte data for color buffer (RGBA)
                var data = new Uint8Array(width * height * 4);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);

                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, this.textureDepth);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);

                udSDKJS_ResizeScene(width, height, 0, 0);
              }
              
              var v = context.camera.viewMatrix;
              udSDKJS_SetMatrix("view", v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[14],v[15]);

              v = context.camera.projectionMatrix;
              udSDKJS_SetMatrix("projection", v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[14],v[15]);

              vpMatrix = context.camera.viewProjectionMatrix;
              udSDKJS_RenderQueue();

              // Get memory address from the color buffer
              var ptr = udSDKJS_GetColourBuffer();
              var data = new Uint8Array(HEAPU8.subarray(ptr, ptr+(width*height*4)));
              // Magenta point
              data[0] = 255;
              data[1] = 0;
              data[2] = 255;
              data[3] = 255;

              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, this.texture);
              gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);

              var ptr = udSDKJS_GetDepthBuffer();
              dataHeap = new Uint8Array(HEAPU8.subarray(ptr, ptr+(width*height*4)));

              gl.activeTexture(gl.TEXTURE1);
              gl.bindTexture(gl.TEXTURE_2D, this.textureDepth);
              gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, dataHeap);

              gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);

              var position = gl.getAttribLocation(this.program, "aVertexPosition");
              gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 16, 0);
              gl.enableVertexAttribArray(position);

              var texCoord = gl.getAttribLocation(this.program, "aVertexUVs");
              gl.vertexAttribPointer(texCoord, 2, gl.FLOAT, false, 16, 8);
              gl.enableVertexAttribArray(texCoord);

              // WebGL expects renders from bottom right corner to top left corner
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

              gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            // Draw continuously
            externalRenderers.requestRender(view);

            // cleanup
            context.resetWebGLState();

            // garbage collect
            v = null;
            data = null;
          },

          /**
           * Loads a shader from a <script> html tag
           */
          getShader: function(gl, id) {
            var shaderScript = document.getElementById(id);
            if (!shaderScript) 
            {
              return null;
            }

            var str = "";
            var k = shaderScript.firstChild;
            while (k) 
            {
              if (k.nodeType == 3) 
              {
                str += k.textContent;
              }
              k = k.nextSibling;
            }

            var shader;
            if (shaderScript.type == "x-shader/x-fragment") 
            {
              shader = gl.createShader(gl.FRAGMENT_SHADER);
            } 
            else if (shaderScript.type == "x-shader/x-vertex") 
            {
              shader = gl.createShader(gl.VERTEX_SHADER);
            } 
            else 
            {
              return null;
            }

            gl.shaderSource(shader, str);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 
            {
              alertUnsupported()
              // alert(gl.getShaderInfoLog(shader));
              return null;
            }

            return shader;
          },

          /**
           * Links vertex and fragment shaders into a GLSL program
           */
          linkProgram: function(gl, fragmentShader, vertexShader) {
            var shaderProgram = gl.createProgram();

            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) 
            {
              return null;
            }
            return shaderProgram;
          },

          /**
           * Initializes all shaders requried by the application
           */
          initShaders: function(context) {
            var gl = context.gl;

            console.log("Loading Shaders!");
            gl.getExtension("EXT_frag_depth");

            console.log("Has fragdepth=" + (gl.getSupportedExtensions().indexOf("EXT_frag_depth") >= 0));

            var fragmentShader = this.getShader(gl, "shader-fs");
            var vertexShader = this.getShader(gl, "shader-vs");
            this.program = this.linkProgram(gl, fragmentShader, vertexShader);
            if (!this.program) {
              alertUnsupported()
            }

            this.textureLocation = gl.getUniformLocation(this.program, "u_texture");
            this.textureLocationDepth = gl.getUniformLocation(this.program, "u_depth");
          }
        };

        // Create the map and view
        var map = new Map({
          basemap: "streets", // hybrid
          ground: "world-elevation"
        });

        var view = new SceneView({
          container: "viewDiv",
          map: map,
          viewingMode: "global",
          qualityProfile: "medium",
          maximumNumberOfFeatures: 60000,
          maximumNumberOfFeaturesExceeded: false,
          environment: {
            lighting: {
              directShadowsEnabled: false
            }
          },
          camera: {
            position: {
              x: 0,
              y: 0,
              z: 30000000,
              spatialReference: {
                wkid: 3857
              }
            },
            heading: 359.47,
            tilt: 0.2
          },
          // Pop-up configureation
          popup: {
            dockEnabled: true,
            dockOptions: {
              // buttonEnabled: false,
              breakpoint: false,
              position: "top-right"
            }
          }
        });
        // assign viewer with this view.
        viewer = view; 

        var homeBtn = new Home({
          view: view,
          viewpoint: new Viewpoint(defaultViewpoint())
        });

        var search = new Search({
          view: view
        });

        // Extrude 3D Symbol for building footprint
        const setSymbolColor = (color) => {
          return {
            // autocasts as new PolygonSymbol3D()
            type: "polygon-3d",
            symbolLayers: [{
              // autocasts as new ExtrudeSymbol3DLayer()
              type: "extrude", 
              material: {
                color: color
              },
              edges: {
                // autocasts as new SolidEdges3D()
                type: "solid",
                color: [50, 50, 50, 0.5]
              }
            }]
          };
        }

        // Color renderer for building footprint
        const renderer = {
          // autocasts as new UniqueValueRenderer()
          type: "unique-value",
          defaultSymbol: setSymbolColor("#FFFFFF"),
          defaultLabel: "Other",
          field: "footprint_type",
          uniqueValueInfos: [
          {
            value: "Structure",
            symbol: setSymbolColor("#73DFFF"),
            label: "Structure"
          },
          {
            value: "Tram Stop",
            symbol: setSymbolColor("#FC921F"),
            label: "Tram Stop"
          },
          {
            value: "Bridge",
            symbol: setSymbolColor("#ED5151"),
            label: "Bridge"
          },
          {
            value: "Train Platform",
            symbol: setSymbolColor("#149ECE"),
            label: "Train Platform"
          }],
          visualVariables: [
            {
              type: "size",
              field: "structure_extrusion"
            }
          ]
        }

        // Feature layer for building footprint
        buildingsLayer = new FeatureLayer({
          url: "https://services8.arcgis.com/EHp4zQcwjqlIUfZd/arcgis/rest/services/2018_building_footprints/FeatureServer/0",
          copyright: "City of Melbourne Open Data Team",
          renderer: renderer,
          opacity: 0.1,
          refreshInterval: 0.05,
          minScale: 15000,
          maxScale: 0,
          elevationInfo: {
            mode: "relative-to-ground"
          },
          title: "Melbourne Build Footprint 2018",
          popupEnabled: true,
          popupTemplate: {
            title: "Building #{ObjectId}",
            content: [
            {
              type: "fields",
              fieldInfos: [
              {
                fieldName: "footprint_type",
                label: "Type"
              },
              {
                fieldName: "roof_type",
                label: "Roof Type"
              },
              {
                fieldName: "structure_extrusion",
                label: "Height (m)"
              },
              {
                fieldName: "structure_id",
                label: "Structure ID"
              }]
            }]
          }
        });

        // Get icon for lights
        const lightsSymbol = (url) => {
          return {
            type: "point-3d", // autocasts as new PointSymbol3D()
            symbolLayers: [
              {
                type: "icon", // autocasts as new IconSymbol3DLayer()
                resource: {
                  href: url
                },
                size: 24,
                outline: {
                  color: "black",
                  size: 1
                }
              }
            ],
            verticalOffset: {
              screenLength: 40,
              maxWorldLength: 200,
              minWorldLength: 35
            },
            callout: {
              type: "line", // autocasts as new LineCallout3D()
              color: "white",
              size: 0.5,
              border: {
                color: "black"
              }
            }
          };
        };

        // Renderer for lights
        const lightsRenderer = {
          // autocasts as new UniqueValueRenderer()
          type: "unique-value",
          field: "SITE_TYPE",
          defaultSymbol: lightsSymbol("./img/light_other.png"),
          defaultValue: "Other Traffic Signal",
          uniqueValueInfos: [
            {
              value: "INT",
              symbol: lightsSymbol("./img/light_traffic.png"),
            },
            {
              value: "POS",
              symbol: lightsSymbol("./img/light_ped.png"),
            }
          ]
        };

        // Feature layer for light posts
        lightsLayer = new FeatureLayer({
          url: "https://services2.arcgis.com/18ajPSI0b3ppsmMt/arcgis/rest/services/traffic_lights/FeatureServer/0",
          copyright: "Department of Transport (Victoria)",
          renderer: lightsRenderer,
          opacity: 0.7,
          refreshInterval: 0.5,
          minScale: 5000,
          maxScale: 0,
          elevationInfo: {
            mode: "relative-to-ground"
          },
          title: "Traffic Lights in City of Melbourne",
          popupEnabled: true,
          popupTemplate: {
            title: "Traffic Light #{SITE_NO}",
            content: [
            {
              type: "fields",
              fieldInfos: [
                {
                  fieldName: "SITE_NAME",
                  label: "Location"
                },
                {
                  fieldName: "SITE_TYPE",
                  label: "Type"
                },
                {
                  fieldName: "STATUS",
                  label: "Status"
                }
              ]
            }]
          },
        });

        // Get Symbol for light posts - Render 2D
        const treeSymbol = {
          type: "simple-fill",  // autocasts as new SimpleFillSymbol()
          color: "green",
          outline: {  // autocasts as new SimpleLineSymbol()
            color: [128, 128, 128, 0.5],
            width: "0.5px"
          }
        }

        // Renderer for ree canopies
        const treeRenderer = {
          // autocasts as new SimpleRenderer()
          type: "simple",
          symbol: treeSymbol,
          label: "Tree areas"
        };

        // Feature Layer for Tree Canopies
        treesLayer = new FeatureLayer({
          url: "https://services8.arcgis.com/EHp4zQcwjqlIUfZd/arcgis/rest/services/tree_canopies_2016_urban_forest/FeatureServer/0",
          copyright: "City of Melbourne Open Data Team",
          renderer: treeRenderer,
          refreshInterval: 0.1,
          minScale: 25000,
          maxScale: 0,
          elevationInfo: {
            mode: "on-the-ground"
          },
          title: "Tree Canopies 2016 in City of Melbourne",
          popupEnabled: true,
          popupTemplate: {
            title: "Area #{area}",
            content: [
            {
              type: "fields",
              fieldInfos: [
                {
                  fieldName: "Shape__Area",
                  label: "Area (m²)"
                },
                {
                  fieldName: "Shape__Length",
                  label: "Length (m)"
                },
              ]
            }]
          },
        });

        
        // Add features into the scene
        map.add(buildingsLayer);
        map.add(lightsLayer);
        map.add(treesLayer);

        // Turn on/off by default checkbox value
        turnBuildingsOnOff();
        turnLightsOnOff();
        turnTreesOnOff();
        
        // Install our external renderer
        externalRenderers.add(view, udSDKRenderer);

        const setActiveTool = (tool) => {
          switch(tool) {
            case "distance": {
              activeWidget = 1;
              setActiveButton(document.getElementById("distanceBtn"));
              break;
            }
            case "area": {
              activeWidget = 2;
              setActiveButton(document.getElementById("areaBtn"));
              break;
            }
            case null: {
              if (activeWidget !== -1) {
                activeWidget = -1;
              }
              break;
            }
          }
        }

        const setActiveButton = (button) => {
          // focus the view to activate the keyboard shortvut as well.
          view.focus();
          const elements = document.getElementsByClassName("active");

          // Deactivate other buttons
          for (let i = 0; i < elements.length; i++) {
            elements[i].classList.remove("active");
          }

          // Activate the selected button if there is any
          if (button) {
            button.classList.add("active");
          }
        }

        // Attach event handling for distance measurement tool.
        document.getElementById("distanceBtn").addEventListener("click", event => {
          setActiveTool(null);
          if (!event.target.classList.contains("active")) {
            setActiveTool("distance");
          } else {
            setActiveButton(null);
          }
        });

        // Attach event handling for area measurement tool.
        document.getElementById("areaBtn").addEventListener("click", event => {
          setActiveTool(null);
          if (!event.target.classList.contains("active")) {
            setActiveTool("area");
          } else {
            setActiveButton(null);
          }
        });

        var legend = new Legend({
          view: view,
          layerInfos: [
            {
              layer: map.layers.getItemAt(0),
              title: "Footprint Type"
            },
            {
              layer: map.layers.getItemAt(1),
              title: "Lights"
            },
            {
              layer: map.layers.getItemAt(2),
              title: "Tree Canopies"
            },
          ],

        });

        var lgExpand = new Expand({
          view: view,
          content: legend
        });

        var shExpand = new Expand({
          view: view,
          content: search
        });

        var optExpand = new Expand({
          expandIconClass: "esri-icon-settings",
          view: view,
          content: document.getElementById("options")
        })

        view.when(function() {
          // Add the home button to the top left corner of the view
          view.ui.add(homeBtn, "top-left");

          // Add the search bar to the top right corner of the view
          view.ui.add(shExpand, "top-right");

          // Add the legend panel to the top right corner of the view
          view.ui.add(lgExpand, "top-right");

          // Add the expandable menu to the top-right corner of the view
          view.ui.add(optExpand, "top-right");

          // Add the measurement toolbar to the top right corner of the view
          view.ui.add("measureTools", "top-right");

          document.getElementById("measureTools").style.display = "block";
          document.getElementById("options").style.display = "block";

          document.getElementById("loginBtn").addEventListener("click", loginVDK);
          function loginVDK(ev) {
            if(udSDKJSReady == 1)
              document.getElementById("statusLoading").style.display = "block";
              setTimeout(async() => {
                LoginVDKPlugin(document.getElementById("usernameTxt").value, document.getElementById("passwordTxt").value);
              }, 100);
          }

          // Move the camera to view Australia.
          moveCameraToAus(view);
          tryAutoLogin(view);
        });

        // symbol for the ground point
        const groundHitSymbol = {
          type: "point-3d",
          symbolLayers: [
            {
              type: "icon", // autocasts as new IconSymbol3DLayer()
              size: 8, // points
              resource: { primitive: "circle" },
              material: { color: "darkgreen" },
              outline: {
                color: "limegreen"
              }
            }
          ]
        };

        // symbol for first object hit point
        const udsHitSymbol = {
          type: "point-3d",
          symbolLayers: [
            {
              type: "icon", // autocasts as new IconSymbol3DLayer()
              size: 8, // points
              resource: { primitive: "circle" },
              material: { color: "darkblue" },
              outline: {
                color: "deepskyblue"
              }
            }
          ]
        };

        const drawPoint = (pos, spatialRef, symbol) => {
          if(pos.length !== 3) {
            throw new Error("position must be a 3-length array!");
            return;
          }
          const point = new Graphic({
            geometry: new Point({
              x: pos[0],
              y: pos[1],
              z: pos[2],
              spatialReference: spatialRef
            }),
            symbol: symbol
          });
          view.graphics.add(point);
        }

        /**
         * Draw a straight line based on two 3D coordinates
         * @name        createDirectine3D
         * @param       {Array}     point1
         * @param       {Array}     point2
         * @param       {Number}    spatialRef
        */
        const createDirectLine3D = (point1, point2, spatialRef) => {
          // return if parameter doesn't fulfill length condition - at least 3 numbers each.
          if(point1 == null || point1.length < 3 || point2 == null || point2.length < 3) {
            return;
          }

          const dLMeasureLayer = new DirectLineMeasurementLayer({
            startPoint: new Point({
              x: point1[0],
              y: point1[1],
              z: point1[2],
              spatialReference: spatialRef
            }),
            endPoint: new Point({
              x: point2[0],
              y: point2[1],
              z: point2[2],
              spatialReference: spatialRef
            }),
          });
          drewLine.push(dLMeasureLayer);
          view.map.add(dLMeasureLayer);
          view.whenLayerView(dLMeasureLayer).then(lv => {
            lv.unit = "metric";
          });
        }

        /**
         * Draw an Area based on multiple 3D coordinates
         * @name        createArea3D
         * @param       {Array[]}     points
         * @param       {Number}      spatialRef
        */
        const createArea3D = (points, spatialRef) => {
          if(!points || points.length < 3) {
            return;
          }
          // Integrity check - check each element has at least 3 values.
          points.forEach((point) => {
            if(point.length < 3) {
              return;
            }
          });
          // Initialise
          let rings = [];
          rings[0] = [];
          points.forEach((point) => {
            rings[0].push(point);
          });

          const polygon = new Polygon({
            hasZ: true,
            rings: rings,
            spatialReference: 3857
          });

          const areaMeasureLayer = new AreaMeasurementLayer({
            geometry: polygon
          });
          drewArea.push(areaMeasureLayer);
          view.map.add(areaMeasureLayer);
          view.whenLayerView(areaMeasureLayer).then(lv => {
            lv.unit = "metric";
          });
        }

        const getDistanceBetween2Points = (point1, point2) => {
          // if either not exist / less than length of 3
          if(!point1 || !point2 || point1.length < 3 || point2.length < 3)
            return;
          let dist = 0;
          point1.forEach((pt1, i) => {
            dist += Math.pow((pt1 - point2[i]), 2);
          })
          return Math.sqrt(dist);
        }

        const toolVisualise = () => {
          // Abort when there is no tool activated.
          if(activeWidget === -1)
            return;
          
          // If user is using direct line tool
          if(activeWidget === 1) {
            // remove previous stuff and refresh
            if(drewLine !== []) {
              drewLine.forEach((line) => {
                view.map.remove(line);
              });
              drewLine = [];
            }
            if(clickedPoints.length < 2)
              return;
            for(let i = 0; i < clickedPoints.length - 1; i += 2) {
              if(i % 2 == 0)
                createDirectLine3D(clickedPoints[i], clickedPoints[i + 1], 3857);
            }
          }
          // if user is using area tool
          else if(activeWidget === 2) {
            if(drewArea !== []) {
              drewArea.forEach((area) => {
                view.map.remove(area);
              });
              drewArea = [];
            }
            // At least 3 points to create an area
            if(clickedPointsArea.length < 3)
              return;
            // find which index is the close to the start point <= 10 units; if not, just use the last point
            let closeIndex = -1;
            let startPoint = clickedPointsArea[0];
            // If you click near the start of the point, it will treat that as a closed area and ignore the rest clicked points
            for(let i = 1; i < clickedPointsArea.length; i++) {
              if(getDistanceBetween2Points(startPoint, clickedPointsArea[i]) < 5.0) {
                closeIndex = i;
                break;
              }
              closeIndex = i;
            }
            // drawing an area with these points
            let drawingPoints = [];
            for(let i = 0; i <= closeIndex; i++) {
              drawingPoints.push(clickedPointsArea[i]);
            }
            // close the ring
            drawingPoints.push(startPoint);
            createArea3D(drawingPoints, 3857);
          }
        }

        // Get the screen point from the view's click event
        view.on("click", async(event) => {
          // If udSDK is not ready, return.
          if (udSDKJSReady !== 2) {
            return;
          }
          let udsWorldPos = null;
          let hitTestPos = null;
          let udsDistance = -1.0;
          let hitDistance = -1.0;
          let cameraPos = view.camera.position;

          udsWorldPos = updateCursorXY(event);
          // Search for graphics at the clicked location. 
          // we need to await this to finish before calculation and comparison
          await view.hitTest(event, { exclude: [view.graphics] })
          .then((response) => {
            let resultGround = response.ground; // ground hit result
            let resultOther = response.results; // results other than ground but non-uds
            if (resultGround.mapPoint !== null) {
              let x = resultGround.mapPoint.x;
              let y = resultGround.mapPoint.y;
              let z = resultGround.mapPoint.z;
              hitDistance = resultGround.distance;
              hitTestPos = [x, y, z];
            }
            // If we hit something else
            else if (resultOther !== null && resultOther.length !== 0) {
              // if there is no ground point returned, we initialise here for comparison.
              if (hitDistance === -1.0) {
                hitDistance = resultOther[0].distance;
                hitTestPos = [resultOther[0].mapPoint.x, resultOther[0].mapPoint.y, resultOther[0].mapPoint.z];
              }
              for (let i = 0; i < resultOther.length; i++) {
                // if We found a nearer point, we update it
                if (resultOther[i].distance < hitDistance) {
                  hitDistance = resultOther[i].distance;
                  hitTestPos = [resultOther[i].mapPoint.x, resultOther[i].mapPoint.y, resultOther[i].mapPoint.z];
                }
              }
            }
            else {
              // set extreme large value when the user didn't click on the ground
              hitDistance = 99999999.0;
            }
          });

          // Calculate distances between camera and uds
          udsDistance = Math.sqrt(
            (Math.pow(cameraPos.x - udsWorldPos[0], 2)
            + Math.pow(cameraPos.y - udsWorldPos[1], 2)
            + Math.pow(cameraPos.z - udsWorldPos[2], 2))
          );
          console.log("Hit Object", udsDistance <= hitDistance ? "UDS Model" : "Map Tiles / Ground");

          // Compare and find which one is nearer.
          if((hitDistance !== -1.0 && udsDistance !== -1.0)) {
            if(activeWidget !== -1) {
              // if uds distance is smaller or equal to ground hit distance, draw point at uds
              if(udsDistance <= hitDistance) {
                // uds measurement doesn't return precisely beyond this value
                if(udsDistance <= 25000.0) {
                  drawPoint(udsWorldPos, 3857, udsHitSymbol);
                  // Depending on which tool, push to what array;
                  activeWidget === 1 ? clickedPoints.push(udsWorldPos) : clickedPointsArea.push(udsWorldPos);
                }
              }
              else {
                if(hitDistance < 99999999.0) {
                  drawPoint(hitTestPos, 3857, groundHitSymbol);
                  // Depending on which tool, push to what array;
                  activeWidget === 1 ? clickedPoints.push(hitTestPos) : clickedPointsArea.push(hitTestPos);
                }
              }
              toolVisualise();
            }
          }
        });
      });

      // translate  point number into words...
      const getResRate = (res) => {
        return (res <= 0.75? "Low" : (res > 0.75 && res <= 1.25 ? "Normal": "High"));
      }

      // Handling function when user changes model resolution.
      const onResChange = () => {
        let res = document.getElementById("modelres").value;
        resolution = res;
        document.getElementById("res").innerHTML = "<p id=\"res\">UDS Model <br/>Resolution: <b>"+getResRate(res)+"</b></p>";
      }

      // handling function when user turn on/off building feature layer.
      const turnBuildingsOnOff = () => {
        let checked = document.getElementById("bfprint").checked;
        buildingsLayer.visible = checked;
      }

      // handling function when user turn on/off lights feature layer.
      const turnLightsOnOff = () => {
        let checked = document.getElementById("flights").checked;
        lightsLayer.visible = checked;
      }

      // handling function when user turn on/off tree canopies feature layer.
      const turnTreesOnOff = () => {
        let checked = document.getElementById("tcanopies").checked;
        treesLayer.visible = checked;
      }

      // handling function when user turn on/off uds models.
      const turnUDSModelOnOff = () => {
        showModel = document.getElementById("udsmodels").checked;
        if(!showModel) {
          unloadUDSModels();
        }
        else {
          loadUDSModel(getModel(userChosen));
        }
      }
      
      // A function that transforms 1 x 16 array into 4x4 matrix, or 1 x 9 into 3x3 array
      const arrayToMatrix = (matrix) => {
        let result = [];
        // Floor and squre root the number of element of the array, make sure index out of bound doesn't happend
        let step = Math.floor(Math.sqrt(matrix.length));
        for(let i = 0, j = -1; i < matrix.length; i++) {
          if(i % step === 0) {
            j++;
            result[j] = [];
          }
          result[j].push(matrix[i]);
        }
        return result;
      }

      const updateCursorXY = (e) => {
        // ignore when udSDK is not ready.
        if(udSDKJSReady !== 2)
          return;

        let element = document.getElementById("viewDiv");
        // get actual coordinate in the view element.
        let actualX = e.x;
        let actualY = e.y;

        if(actualX < 0.0 || actualY < 0.0)
          return;
        cursorX = Math.round(actualX);
        cursorY = Math.round(actualY);

        // console.log("Clicked Screen Coord: X:", cursorX, ", Y:", cursorY);
        let depth = getCursorDepth(cursorX, cursorY, resolution, element.clientWidth);
        // console.log("Depth at (", cursorX, ",", cursorY, "):", depth);
        let udsWorldPos = getWorldPosition(vpMatrix, cursorX, cursorY, element.clientWidth, element.clientHeight, depth, resolution);
        return udsWorldPos;
      }

      // Get depth from that cursor point
      const getCursorDepth = (x, y, res, width) => {
        if(x != -1 && y != -1) {
          let depth = new Uint8Array(4);

          for(var i = 0; i < 4; i++) {
            let index = Math.round((Math.floor(x * res) + (Math.floor(y * res) * Math.floor(width * res))) * 4) + i;
            depth[i] = dataHeap[index];
          }
          depth.reverse();
          // convert 4-byte numbers into depth floating number
          // Create buffer
          let buffer = new ArrayBuffer(4);
          // Create Data view for the buffer
          let view = new DataView(buffer);
          // Set DataView Bytes
          depth.forEach((b, i) => {
            view.setUint8(i, b);
          });
          // We got the first 32-bit floating number
          let num = view.getFloat32(0);
          return num;
        }
      }

      const getInverseViewProjMatrix = (viewMat, projMat) => {
        let prod = math.multiply(projMat, viewMat);
        // console.log("View Projection Matrix (Not Inversed): ", prod);
        return math.inv(prod);
      }

      const mag3 = (arr3) => {
        return Math.sqrt(arr3[0] * arr3[0] + arr3[1] * arr3[1] + arr3[2] * arr3[2]);
      };

      const mag2 = (arr3) => {
        return Math.sqrt(arr3[0] * arr3[0] + arr3[1] * arr3[1]);
      };

      const getWorldPosition = (vpMatrix, cursorX, cursorY, width, height, uDepth, res) => {

        cursorX *= res;
        cursorY *= res;
        width *= res;
        height *= res;

        // Initialise result
        let result;
        let invViewProjMatrix = math.inv(arrayToMatrix(vpMatrix));

        // Get transformed mouse x, y and depth, assign one by one makes more readable
        let transformDepth = new Array(4);
        transformDepth[0] = ((cursorX / width) * 2.0) - 1.0;
        transformDepth[1] = -(((cursorY / height) * 2.0) - 1.0); // flip
        transformDepth[2] = uDepth; // * 2.0 - 1.0;
        transformDepth[3] = 1.0;

        result = math.multiply(transformDepth, invViewProjMatrix);
        result = math.divide(result, result[3]);
		
        // transform from cartesian->lat/long->3857
        let earthRadius = 6378137.0;		
        let lla_lat = Math.atan2(result[2], mag2(result));
        let lla_long = Math.atan2(result[1], result[0]);
        let lla_alt = mag3(result) - earthRadius;
          
        let resultX = lla_long * earthRadius;
        let resultY = Math.log(Math.tan(Math.PI * 0.25 + lla_lat * 0.5)) * earthRadius;
      
        // console.log("Lat: ", lla_lat, ", Long: ", lla_long, ", alt:", lla_alt, " : resultX: ", resultX, ", resultY: ", resultY);
        return [resultX, resultY, lla_alt];
      }
    </script>
    <div class="head-container">
      <div class="title">
        <img src="./img/EuclideonLogo_Std.svg" width="150px" alt="logo"/>
        <h1>ESRI City Viewer</h1>
      </div>
      <br/>
    </div>
  </head>
  <body>
    <script>
      const udSDKjs = document.createElement('script');
      udSDKjs.src = './udSDK/udSDKjs.js';
      document.body.appendChild(udSDKjs);

      const easyudSDKjs = document.createElement('script');
      easyudSDKjs.src = './udSDK/easyudSDKjs.js';
      document.body.appendChild(easyudSDKjs);
    </script>
    <div id="container">
      <div id="left">
        <div id="viewDiv" class="viewDiv"></div>
      </div>
      <div id="right">
        <div id="navigator" class="navigator">
          <div id="navBtn"></div>
        </div>
      </div>
    </div>
    <div id="statusLoading" class="statusBox">
      <div class="loader"></div>
      <span>Loading...</span>
    </div>
    <div class="loginBox" id="loginBox" style="display: none;">
      <table>
        <h2>Euclideon Login</h2>
        <tr><td><label for="usernameTxt">Email: </label></td>
          <td><input id="usernameTxt" type="text" placeholder="Email" /></td></tr>
        <tr><td><label for="passwordText">Password: </label></td>
          <td><input id="passwordTxt" type="password" placeholder="Password" /></td></tr>
      </table>
      <button id="loginBtn">Login</button><br/>
      <span class="errorMessage" id="errorMessage"></span>
    </div>
    <div class="options" id="options">
      <b>Options</b><br/><br/>
      <input type="checkbox" id="bfprint" name="bfprint" onclick="turnBuildingsOnOff()" unchecked>Buildings<br/>
      <input type="checkbox" id="flights" name="flights" onclick="turnLightsOnOff()" unchecked>Traffic Lights<br/>
      <input type="checkbox" id="tcanopies" name="tcanopies" onclick="turnTreesOnOff()" unchecked>Tree Canopies<br/>
      <input type="checkbox" id="udsmodels" name="udsmodels" onclick="turnUDSModelOnOff()" checked>UDS Models<br/>
      <p id="res">UDS Model <br/>Resolution: <b>Normal</b></p>
      <input type="range" id="modelres" min="0.5" max="1.5" value="1.0" step="0.25" class="slider" oninput="onResChange()">
    </div>
    <div class="measureTools" id="measureTools">
      <button
        class="action-button esri-icon-measure-line"
        id="distanceBtn"
        type="button"
        title="Measure distance between two points"
        value="distance"
      ></button>
      <br/>
      <button
        class="action-button esri-icon-measure-area"
        id="areaBtn"
        type="button"
        title="Measure area"
        value="area"
      ></button>
    </div>
    <div class="unsupportMsg">
      <h1>Sorry, this device is not supported.</h1>
      <h2>
        Viewing on a mobile or tablet device? This demo is a desktop application only. We support the latest versions of Google Chrome and Microsoft Edge on Windows, Mac, and Ubuntu.
      </h2>
      <a href="https://www.euclideon.com/udsdk/#udstream-nav-demo" rel="noopener noreferrer">Go Back</a>
    </div>
    <script>
      function tryAutoLogin(view)
      {
        var status = udSDKJS_Domain("Esri ArcScene");
        if (status == 0)
        {
          console.log("udSDKJS Logged in.");

          udSDKJSReady = 2;
          document.getElementById("loginBox").style.display = "none";
          document.getElementById("statusLoading").style.display = "none";

          // From loadModel.js
          unload_LoadUDSModel("Melbourne");
          // From cameraControl.js
          flyCamera(view, "Melbourne", 5.0);
        }
        else
        {
          document.getElementById("loginBox").style.display = "block";
          setTimeout(() => {
            document.getElementById("statusLoading").style.display = "none";
          }, 1000)
        }
      }

      function CreateVDKPlugin()
      {
        udSDKJSReady = 1;
      };

      function LoginVDKPlugin(username, password)
      {
        if (udSDKJSReady != 1)
          Alert("Not ready to login!");

        var status = udSDKJS_Login(username, password, "Esri ArcScene");

        if (status == 0)
        {
          console.log("udSDKJS Logged in.");

          udSDKJSReady = 2;
          document.getElementById("loginBox").style.display = "none";
          document.getElementById("statusLoading").style.display = "none";

          // From loadModel.js
          unload_LoadUDSModel("Melbourne");
          // From cameraControl.js
          flyCamera(viewer, "Melbourne", 5.0);
        }
        else
        {
          if (status == 13)
            document.getElementById("errorMessage").innerText = "udSDKJS Error / Email or Password Wrong";
          else
            document.getElementById("errorMessage").innerText = "udSDKJS FAILED Error=" + status;
        }
      }

      var Module = {
        noExitRuntime: true,
        preRun: [],
        postRun: CreateVDKPlugin,
        setStatus: function(text) {
          if (!Module.setStatus.last)
            Module.setStatus.last = { time: Date.now(), text: '' };

          if (text === Module.setStatus.last.text)
            return;

          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30)
            return; // if this is a progress update, skip it if too soon

          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
          }

          console.log(text);
        },
        totalDependencies: 0,
        monitorRunDependencies: function(left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
        }
      };

      Module.setStatus('Downloading...');
    </script>
    <script>

      // Calculate container's height
      function calcContHeight(width) 
      {
        return (width >= 524 ? "16%" : width >= 397 ? "20%" : width >= 270? "24%" : "45%");
      }
    
      // Listen on windows resize
      function onWindowResize() 
      {
        // Get width and height of the window excluding scrollbars
        var w = window.innerWidth;
        var h = window.innerHeight;
        // less than 1024 px define as mobile device
        if(w <= 1024) 
        {
          document.getElementById("left").style.height = parseInt(h * 9 / 16)+"px";
          document.getElementById("viewDiv").style.height = parseInt(h * 9 / 16)+"px";
          document.getElementById("statusLoading").style.top = parseInt((h * 9 / 16) - 100)+"px";
        }
        else 
        {
          document.getElementById("left").style.height =  parseInt(w * 0.8 * 9 / 16)+"px"; // "690px";
          // Change to 16:9 Aspect Ratio.
          document.getElementById("viewDiv").style.height = parseInt(w * 0.8 * 9 / 16)+"px";
          // Fix loading indicator pos
          document.getElementById("statusLoading").style.top = parseInt((w * 0.8 * 9 / 16) - 100)+"px";
          // Minimum size of the window must not smaller than 600px.
          if(parseInt(document.getElementById("viewDiv").style.height) < 600) 
          {
            document.getElementById("viewDiv").style.height = "600px";
            document.getElementById("statusLoading").style.top = "500px";
          }
            
          // Set the container size as well prevent text being hided by the window.
          document.getElementById("left").style.height = document.getElementById("viewDiv").style.height;
          
        }
      }

      function isMobileDevice() 
      {
        // Mobile Devices
        if(navigator.userAgent.toLowerCase().match(/mobile/i)) 
        {
          console.log("contains mobile: ", true);
          return true;
        }
        // Tablet Devices
        if(navigator.maxTouchPoints && navigator.maxTouchPoints > 2) 
        {
          console.log("max touch points: ", navigator.maxTouchPoints);
          return true;
        }
        // console.log("Not mobile device!");
        return false;
      }

      function isSupportSAB() 
      {
        try 
        {
          // Try creating a share array buffer object.
          const buffer = new SharedArrayBuffer(8);
        }
        catch (e) 
        {
          console.log("Shared Array Buffer Unsupported!");
          return false;
        }
        return true;
      }

      function hideApp() 
      {
        // Don't hide app directly as the the warning message will disappear as well.
        document.getElementById("container").style.display = "none";
        document.getElementsByClassName("unsupportMsg")[0].style.display = "block";
        document.getElementById("loginBox").style.display = "none";
        document.getElementById("statusLoading").style.display = "none";
      }

      function alertUnsupported() 
      {
        if(isMobileDevice() || !isSupportSAB()) 
        {
          hideApp();
          throw new Error("This device is unsupported!");
        }
      }

      // Attaching the event listener function to window's resize event
      window.addEventListener("resize", onWindowResize);
      // A load event detects whether users are using unsupported devices.
      window.addEventListener("load", alertUnsupported);
      // Calling the function for the first time
      onWindowResize();
    </script>
  </body>
</html>
